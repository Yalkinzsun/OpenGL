## Матрицы

Для работы программы необходимы следующие библиотеки:

1. GLEW (для упрощения запроса и загрузки расширений OpenGL)

2. GLFW (для создания и открытия окон, создания OpenGL контекста и управления вводом)

3. GLM (трехмерной математики)

   

Также необходимо подключить шейдер:
```c++
#include <common/shader.hpp>
```

**Шейдер** (англ. *shader* «затеняющий») — компьютерная программа, предназначенная для исполнения процессорами видеокарты (GPU)

Библиотеки должны быть проинициализированы. Например, для начала работы с библиотекой GLFW это можно сделать при помощи вызова **glfwInit()** 

```c++
if (!glfwInit())
    exit(-1);
```

При завершении работы с GLFW, следует вызывать функцию **glfwTerminate()**. Этот вызов закроет все открытые окна и освободит выделенные ресурсы.

Используется OpenGL версии **2.1**:

```c++
glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);
glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);
```

Для создания окна и контекста OpenGL в GLFW служит функция **glfwCreateWindow()**:

```c++
window = glfwCreateWindow( 300, 300, "Первое окно", NULL, NULL);
```

В аргументах данной функции указываются размеры окна в *px* и его заголовок 

Прежде чем использовать команды для рендеринга в созданное 
окно его нужно сделать его текущим контекстом при помощи функции **glfwMakeContextCurrent()**:

```c++
glfwMakeContextCurrent(window);
```

Цвет окна меняется с помощью функции **glClearColor()**:

```c++
glClearColor(0.1f, 0.6f, 0.0f, 0.0f);
```

Первый аргумент функции отвечает за красный цвет, второй за зелёный и третий за синий (RGB-модель: red, green, blue) 

Чтобы увидеть цвет на созданном окне необходимо в цикле **do {...}** Очистить буфер цвета *GL_COLOR_BUFFER_BIT*:
```с++
do{
		glClear( GL_COLOR_BUFFER_BIT );

	...
}
```

*<--- Начало теоретического отступления --->*

В трехмерной графике будем использовать только матрицы **4x4**, 
которые позволят трансформировать вершины (x, y, z, w). 
Трансформированная вершина является результатом умножения матрицы на саму вершину:

```c++
//GLM

glm::mat4 myMatrix;
glm::vec4 myVector;

glm::vec4 transformedVector = myMatrix * myVector; // Порядок имеет значение

// GLSL
mat4 myMatrix;
vec4 myVector;

vec4 transformedVector = myMatrix * myVector;
```

**Матрица переноса** выглядит так:

![](https://github.com/Yalkinzsun/OpenGL/blob/master/%D0%97%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F/3.%20%D0%9C%D0%B0%D1%82%D1%80%D0%B8%D1%86%D1%8B/transfer_matrix.png)

где X, Y, Z - это значения, которые необходимо добавить к вектору

Перенос вектора (10, 10, 10, 1) на 10  в направлении X:

```c++
// GLM
glm::mat4 myMatrix = glm::translate(glm::mat4(), glm::vec3(10.0f, 0.0f, 0.0f));
glm::vec4 myVector(10.0f, 10.0f, 10.0f, 0.0f);
glm::vec4 transformedVector = myMatrix * myVector;

// GLSL
vec4 transformedVector = myMatrix * myVector;
```

**Матрица масштабирования** выглядит так:

![](https://github.com/Yalkinzsun/OpenGL/blob/master/%D0%97%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F/3.%20%D0%9C%D0%B0%D1%82%D1%80%D0%B8%D1%86%D1%8B/scaling_matrix.png)

Применить масштабирование вектора (позиции или направления - это не важно) на 2.0 во всех направлениях:

```c++
glm::mat4 myScalingMatrix = glm::scale(2.0f, 2.0f ,2.0f);

```
*<--- Конец теоретического отступления --->*

**1) Создание MVP матрицы.** Это должно быть сделано для каждой модели, которую необходимо отобразить:

```c++
// Проекционная матрица : 45&deg; поле обзора, 4:3 соотношение сторон, диапазон : 0.1 юнит <-> 100 юнитов
glm::mat4 Projection = glm::perspective(glm::radians(45.0f), 4.0f / 3.0f, 0.1f, 100.0f);

// Или, для ортокамеры
glm::mat4 View       = glm::lookAt(
    glm::vec3(4,3,3), // Камера находится в мировых координатах (4,3,3)
    glm::vec3(0,0,0), // И направлена в начало координат
    glm::vec3(0,1,0)  // "Голова" находится сверху
);

// Матрица модели : единичная матрица (Модель находится в начале координат)
glm::mat4 Model = glm::mat4(1.0f);  // Индивидуально для каждой модели

// Итоговая матрица ModelViewProjection, которая является результатом перемножения наших трех матриц
glm::mat4 MVP = Projection * View * Model; 
```

**2) Передать вышеуказанный фрагмент кода в GLSL:**

```c++
// Получить хэндл переменной в шейдере
// Только один раз во время инициализации.
GLuint MatrixID = glGetUniformLocation(programID, "MVP");

// Передать трансформации в текущий шейдер
// Это делается в основном цикле, поскольку каждая модель будет иметь другую MVP-матрицу (как минимум часть M)
glUniformMatrix4fv(MatrixID, 1, GL_FALSE, &MVP[0][0]);
```

**3) Использование полученных данных в GLSL, чтобы трансформировать вершины:**

```c++
// Входные данные вершин, разные для всех исполнений этого шейдера.
  layout(location = 0) in vec3 vertexPosition_modelspace;
  
// Значения, которые остаются постоянными для всей сетки.
  uniform mat4 MVP;
  
  void main(){
    // Выходная позиция вершины: MVP * position
    gl_Position =  MVP * vec4(vertexPosition_modelspace,1);
  }
```

Проверить нажатие клавиши Escape или закрытие окна можно с помощью следующего цикла: 

```c++
while( glfwGetKey(window, GLFW_KEY_ESCAPE ) != GLFW_PRESS &&
glfwWindowShouldClose(window) == 0 );
```


#### Результат выполнения программы:

![](https://github.com/Yalkinzsun/OpenGL/blob/master/screenshots/3.png)

