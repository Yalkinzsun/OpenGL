## Текстурированный куб

Для работы программы необходимы следующие библиотеки:

1. GLEW (для упрощения запроса и загрузки расширений OpenGL)

2. GLFW (для создания и открытия окон, создания OpenGL контекста и управления вводом)

3. GLM (трехмерной математики)

   

Также необходимо подключить шейдер:

```c++
#include <common/shader.hpp>
```

**Шейдер** (англ. *shader* «затеняющий») — компьютерная программа, предназначенная для исполнения процессорами видеокарты (GPU)

Библиотеки должны быть проинициализированы. Например, для начала работы с библиотекой GLFW это можно сделать при помощи вызова **glfwInit()** 

```c++
if (!glfwInit())
    exit(-1);
```

При завершении работы с GLFW, следует вызывать функцию **glfwTerminate()**. Этот вызов закроет все открытые окна и освободит выделенные ресурсы.

Используется OpenGL версии **2.1**:

```c++
glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);
glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);
```

Для создания окна и контекста OpenGL в GLFW служит функция **glfwCreateWindow()**:

```c++
window = glfwCreateWindow( 300, 300, "Первое окно", NULL, NULL);
```

В аргументах данной функции указываются размеры окна в *px* и его заголовок 

Прежде чем использовать команды для рендеринга в созданное 
окно его нужно сделать его текущим контекстом при помощи функции **glfwMakeContextCurrent()**:

```c++
glfwMakeContextCurrent(window);
```

Цвет окна меняется с помощью функции **glClearColor()**:

```c++
glClearColor(0.1f, 0.6f, 0.0f, 0.0f);
```

Первый аргумент функции отвечает за красный цвет, второй за зелёный и третий за синий (RGB-модель: red, green, blue) 

Чтобы увидеть цвет на созданном окне необходимо в цикле **do {...}** Очистить буфер цвета *GL_COLOR_BUFFER_BIT*:

```с++
do{
		glClear( GL_COLOR_BUFFER_BIT );

	...
}
```

#### UV-координаты

При текстуризации какого-то объекта, то необходимо сообщить OpenGL, какая часть изображения прикрепляется к каждому  треугольнику. Именно для этого используются UV-координаты

Каждая вершина помимо позиции имеет несколько дополнительных полей, а  также U и V. Эти координаты используются применительно к текстуре, как  показано на рисунке:

![](https://github.com/Yalkinzsun/OpenGL/blob/master/%D0%97%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F/5.%20%D0%A2%D0%B5%D0%BA%D1%81%D1%82%D1%83%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B8%CC%86%20%D0%BA%D1%83%D0%B1/UV.png)

Создание текстур очень похоже на создание вершинных буферов (см. задание 4):

- Создание текстуры
- Привязка текстуры
- Заполнение
- Конфигурация 

**GL_RGB** в **glTextImage2D** указывает на то, что мы работаем с 3х 
компонентным цветом. А **GL_BGR** указывает на то, как данные представлены в памяти. На самом деле в BMP-файлах цветовые данные хранятся не в RGB, а в BGR (если быть точным, то это связано с тем, как хранятся числа в 
памяти), поэтому необходимо сообщить об этом OpenGL:

```c++
// Создадим одну текстуру OpenGL
GLuint textureID;
glGenTextures(1, &textureID);

// Сделаем созданную текстуру текущий, таким образом все следующие функции будут работать именно с этой текстурой
glBindTexture(GL_TEXTURE_2D, textureID);

// Передадим изображение OpenGL
glTexImage2D(GL_TEXTURE_2D, 0,GL_RGB, width, height, 0, GL_BGR, GL_UNSIGNED_BYTE, data);

glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
```

**Использование функцию loadBMP_custom() для загрузки текстуры:**

```c++
GLuint Texture = loadBMP_custom("uvtemplate.bmp");
```

Фрагментный шейдер:

```c++
#version 330 core

// Интерполированные значения из вершинного шейдера
in vec2 UV;

// Выходные данные
out vec3 color;

// Значения, которые остаются неизменными для объекта.
uniform sampler2D myTextureSampler;

void main(){

    // Выходной цвет = цвету текстуры в указанных UV-координатах
    color = texture( myTextureSampler, UV ).rgb;
}
```

#### Результат выполнения программы:

![](https://github.com/Yalkinzsun/OpenGL/blob/master/screenshots/5.png)

