## Цветной куб

Для работы программы необходимы следующие библиотеки:

1. GLEW (для упрощения запроса и загрузки расширений OpenGL)

2. GLFW (для создания и открытия окон, создания OpenGL контекста и управления вводом)

3. GLM (трехмерной математики)

   

Также необходимо подключить шейдер:
```c++
#include <common/shader.hpp>
```

**Шейдер** (англ. *shader* «затеняющий») — компьютерная программа, предназначенная для исполнения процессорами видеокарты (GPU)

Библиотеки должны быть проинициализированы. Например, для начала работы с библиотекой GLFW это можно сделать при помощи вызова **glfwInit()** 

```c++
if (!glfwInit())
    exit(-1);
```

При завершении работы с GLFW, следует вызывать функцию **glfwTerminate()**. Этот вызов закроет все открытые окна и освободит выделенные ресурсы.

Используется OpenGL версии **2.1**:

```c++
glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);
glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);
```

Для создания окна и контекста OpenGL в GLFW служит функция **glfwCreateWindow()**:

```c++
window = glfwCreateWindow( 300, 300, "Первое окно", NULL, NULL);
```

В аргументах данной функции указываются размеры окна в *px* и его заголовок 

Прежде чем использовать команды для рендеринга в созданное 
окно его нужно сделать его текущим контекстом при помощи функции **glfwMakeContextCurrent()**:

```c++
glfwMakeContextCurrent(window);
```

Цвет окна меняется с помощью функции **glClearColor()**:

```c++
glClearColor(0.1f, 0.6f, 0.0f, 0.0f);
```

Первый аргумент функции отвечает за красный цвет, второй за зелёный и третий за синий (RGB-модель: red, green, blue) 

Чтобы увидеть цвет на созданном окне необходимо в цикле **do {...}** Очистить буфер цвета *GL_COLOR_BUFFER_BIT*:
```с++
do{
		glClear( GL_COLOR_BUFFER_BIT );

	...
}
```

Куб имеет 6 прямоугольных граней, однако OpenGL знает только о 
треугольниках, поэтому все, что необходимо сделать - это **вывести 12 треугольников**, значит необходимо 12 * 3 = 36 вершин:

```c++
static const GLfloat g_vertex_buffer_data[] = {
    -1.0f,-1.0f,-1.0f, // Треугольник 1 : начало
    -1.0f,-1.0f, 1.0f,
    -1.0f, 1.0f, 1.0f, // Треугольник 1 : конец
    1.0f, 1.0f,-1.0f, // Треугольник 2 : начало
    -1.0f,-1.0f,-1.0f,
    -1.0f, 1.0f,-1.0f, // Треугольник 2 : конец
    1.0f,-1.0f, 1.0f,
    -1.0f,-1.0f,-1.0f,

          ...
              
    -1.0f, 1.0f, 1.0f,
    1.0f, 1.0f, 1.0f,  // Треугольник 12 : конец
    -1.0f, 1.0f, 1.0f,
    1.0f,-1.0f, 1.0f  // Треугольник 12 : конец
};
```

**Процедура вывода:**

```c++
glDrawArrays(GL_TRIANGLES, 0, 12*3); // 12*3 индексов начинающихся с 0. -> 12 треугольников -> 6 граней.
```

### Добавление цвета

Объявление цветов - один RGB триплет на вершину. Этот массив был сгенерирован случайно:

```c++
static const GLfloat g_color_buffer_data[] = {
    0.583f,  0.771f,  0.014f,
    0.609f,  0.115f,  0.436f,
    0.327f,  0.483f,  0.844f,
    0.822f,  0.569f,  0.201f,
    0.435f,  0.602f,  0.223f,
    0.310f,  0.747f,  0.185f,
    
              ...
    
    0.053f,  0.959f,  0.120f,
    0.393f,  0.621f,  0.362f,
    0.673f,  0.211f,  0.457f,
    0.820f,  0.883f,  0.371f,
    0.982f,  0.099f,  0.879f
};
```

Создание, привязывание и заполнения буфера:

```c++
GLuint colorbuffer;
glGenBuffers(1, &colorbuffer);
glBindBuffer(GL_ARRAY_BUFFER, colorbuffer);
glBufferData(GL_ARRAY_BUFFER, sizeof(g_color_buffer_data), g_color_buffer_data, GL_STATIC_DRAW);
```

Конфигурация:

```c++
// Второй буфер атрибутов - цвета
glEnableVertexAttribArray(1);
glBindBuffer(GL_ARRAY_BUFFER, colorbuffer);
glVertexAttribPointer(
    1,                                // Атрибут. Здесь необязательно указывать 1, но главное, чтобы это значение совпадало с layout в шейдере..
    3,                                // Размер
    GL_FLOAT,                         // Тип
    GL_FALSE,                         // Нормализован?
    0,                                // Шаг
    (void*)0                          // Смещение
);
```

Проверить нажатие клавиши Escape или закрытие окна можно с помощью следующего цикла: 

```c++
while( glfwGetKey(window, GLFW_KEY_ESCAPE ) != GLFW_PRESS &&
glfwWindowShouldClose(window) == 0 );
```



#### Результат выполнения программы:

![](https://github.com/Yalkinzsun/OpenGL/blob/master/screenshots/4.png)

